
# 分布式锁

锁的的基本概念：
- 通过锁可以实现在多个线程或多个进程间在争抢资源时，能够合理的分配置资源的所有权。
- 在单体应用中我们可以通过 synchronized 或ReentrantLock 来实现锁。
- 但在分布式系统中，仅仅是加synchronized 是不够的，需要借助第三方组件来实现。
- 比如一些简单的做法是使用 关系型数据行级锁来实现不同进程之间的互斥，但大型分布式系统的性能瓶颈往往集中在数据库操作上。
- 为了提高性能得采用如Redis、Zookeeper之内的组件实现分布式锁。

共享锁：
- 也称作只读锁，当一方获得共享锁之后，其它方也可以获得共享锁。但其只允许读取。
- 在共享锁全部释放之前，其它方不能获得写锁。

排它锁：
- 也称作读写锁，获得排它锁后，可以进行数据的读写。
- 在其释放之前，其它方不能获得任何锁。

## 锁的获取：

某银行帐户，可以同时进行帐户信息的读取，但读取其间不能修改帐户数据。其帐户ID为:888

![](https://img-blog.csdnimg.cn/20200710170428574.png)

获得读锁流程：
1. 基于资源ID创建临时序号读锁节点  /lock/888.R0000000002 Read 
2. 获取 /lock 下所有子节点，判断其最小的节点是否为读锁，如果是则获锁成功
3. 最小节点不是读锁，则阻塞等待。添加lock/ 子节点变更监听。
4. 当节点变更监听触发，执行第2步


![](https://img-blog.csdnimg.cn/20200710171355666.png)

获得写锁：
1. 基于资源ID创建临时序号写锁节点 /lock/888.R0000000002 Write 
2. 获取 /lock 下所有子节点，判断其最小的节点是否为自己，如果是则获锁成功
3. 最小节点不是自己，则阻塞等待。添加lock/ 子节点变更监听。
4. 当节点变更监听触发，执行第2步

释放锁：
1. 读取完毕后，手动删除临时节点，如果获锁期间宕机，则会在会话失效后自动删除。

关于羊群效应：
- 在等待锁获得期间，所有等待节点都在监听 Lock节点，
- 一但lock 节点变更所有等待节点都会被触发，然后在同时反查Lock 子节点。
- 如果等待对例过大会使用Zookeeper承受非常大的流量压力。
- 为了改善这种情况，可以采用监听链表的方式，
- 每个等待对列只监听前一个节点，如果前一个节点释放锁的时候，才会被触发通知。这样就形成了一个监听链表。

